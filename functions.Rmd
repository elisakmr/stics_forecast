---
title: "Functions"
output: html_document
---

```{r setup, include=FALSE}

dir_data <- "D:/HOME/ekamir/scoring_medscope/data/stics" 
dir_plot <- "D:/HOME/ekamir/scoring_medscope/figure"

library(dplyr)
library(stats)

functioning <- function(x,y){
  veriApply("BrierScore2", x, y)$bs
}

```

## ROC aggregated at box level
# function computing scores for the box, weighting points as function of latitude

```{r setup, include=FALSE}
score_boite_prob = function(prev_prob, obs_bin, lati, nb_bin, e)
{
  # Calcul de HR et FAR pour scores ROC et diag de fiabilite sur des zones.
  # Agregation des previsions probabilistes de chaque point,
  # en applicant une ponderation.
  # NB : les previsions sont exprimees en proba (entre 0. et 1.)  !!!!
  # e= 1 > Higher tercile
  # e= 2 > Lower tercile
  # e= 3 > Higher quintile
  # e= 4 > Lower quintile
  
  O=numeric(nb_bin)          # occurences bien prevues (hits)
  NO=numeric(nb_bin)         # fausses alertes
  HR=numeric(nb_bin)         # taux de bonnes previs agreges (pour ROC)
  FAR=numeric(nb_bin)        # taux de fausses alertes (pour ROC)
  HR_rel=numeric(nb_bin)     # taux bonnes previs par bin (pour diag fiabilite)
  F_rel=numeric(nb_bin)      # freq des previs pour chaque bin (pour diag fiabilite)
  ngrids=dim(prev_prob)[1]
  # boucle sur les points de la zone
  
  for (i in (1:ngrids)) {
    pred=prev_prob[i,,e]
    obs=obs_bin[i,,e]
  
    for (bin in (1:nb_bin-1)) {
      O[bin] = O[bin] + cos(pi*lati[i]/180)*length(which(pred>=((bin-1)/nb_bin) & pred<(bin/nb_bin) & obs==1))
      NO[bin] = NO[bin] + cos(pi*lati[i]/180)*length(which(pred>=((bin-1)/nb_bin) & pred<(bin/nb_bin) & obs==0))
    }
    O[nb_bin] = O[nb_bin] + cos(pi*lati[i]/180)*length(which(pred>=((nb_bin-1)/nb_bin) & pred<=1. & obs==1))
    NO[nb_bin] = NO[nb_bin] + cos(pi*lati[i]/180)*length(which(pred>=((nb_bin-1)/nb_bin) & pred<=1. & obs==0))
  }
  
  # cumuls (pour ROC)
  for (bin in (1:nb_bin)) {
    # pour courbe ROC
    HR[bin] = sum(O[bin:nb_bin])/sum(O[])
    FAR[bin] = sum(NO[bin:nb_bin])/sum(NO[])
  }
  # taux par bin (pour diag de fiabilite)
  HR_rel=O/(O+NO)
  F_rel=(O+NO)/sum(O[]+NO[])
  
  # calcul AUC (cf http://stackoverflow.com/questions/4954507/calculate-the-area-under-a-curve-in-r)
  AUC=-sum(diff(FAR) * (head(HR,-1)+tail(HR,-1)))/2
  
  liste_score = list(HR=HR,FAR=FAR, HR=HR, FAR=FAR, AUC=AUC)
  return(liste_score)
  
}
```

## Background map

```{r setup, include=FALSE}

 key = "AIzaSyCD2-pP0yfM8aC8sjCB4g--CaCcExP6NhU"; "AIzaSyB24WUzCzX1lErLgsVLtio1c7QxLfw1_SA"
 register_google(key = "AIzaSyB24WUzCzX1lErLgsVLtio1c7QxLfw1_SA")
 back_map <- get_map(location = c(1.2, 41, 10, 46), maptype = "satellite", source = "google") 

```

## BRIER score aggregated at box level
# function computing scores for the box, weighting points as function of latitude

```{r setup, include=FALSE}

brier_score_boite = function(prev_prob, obs_bin, lati, e){
  
  coeff_lat <- vector()
  somme <- 0
   for (i in (1:ngrids)) {
     int = sum(cos(pi*lati[i]/180)*(prev_prob[i,,e]-obs_bin[i,,e])^2)
     somme=somme+int
     coeff_lat[i] <- cos(pi*lati[i]/180)
      
   }
  
  bs=somme/(sum(24*coeff_lat))
  return(bs)
}

brier_score_boite(prob_ps, bin_ref, lat, 1)

```



